{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Sommaire","text":"<p>Bienvenue sur mon site d\u00e9di\u00e9 \u00e0 la programmation graphique et au d\u00e9veloppement de jeux. Vous trouverez ici diff\u00e9rents tutoriels et travaux dirig\u00e9s autour du rendu en temps r\u00e9el, de l\u2019analyse GPU et des outils de d\u00e9bogage.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li> <p>Index</p> </li> <li> <p>Index</p> </li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Index</li> <li>Index</li> </ul>"},{"location":"#gpu-profiling","title":"GPU Profiling","text":"<ul> <li>00 Introduction</li> <li>01 Frame Analysis \u2014 Analyse d\u2019une frame captur\u00e9e dans Unity avec RenderDoc.</li> <li>02 GPU profiling \u2014 Avec Pix</li> <li>03 Rapport de profiling \u2014 Qu\u2019est-ce que c\u2019est et comment le construire</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#liste-des-tutos","title":"Liste des tutos","text":"<ul> <li>LearnOpenGL tutorials</li> <li>GPU Profiling</li> </ul>"},{"location":"tutorials/GPUProfiling/00_Introduction/","title":"Profiling GPU \u2013 Introduction (30 min)","text":""},{"location":"tutorials/GPUProfiling/00_Introduction/#introduction","title":"Introduction","text":"<p>Dans ce tutoriel, nous allons explorer les m\u00e9thodes permettant de comprendre et de profiler le pipeline de rendu d'une frame de jeu.</p> <p>Une optimisation doit toujours d\u00e9couler d\u2019une observation pr\u00e9cise. Sans cela, on risque de perdre du temps, de g\u00e9n\u00e9rer des bugs ou d\u2019aboutir \u00e0 une mauvaise compr\u00e9hension du comportement de la frame.</p> <p>Pour analyser une frame, il est essentiel de d\u00e9finir le contexte dans lequel on souhaite l\u2019\u00e9tudier : - Platform et architecture mat\u00e9rielle - Settings graphiques - Contexte in-game - Mode de rendu (API graphique, tile-based rendering, forward, gbuffer, autres) - Mode de build  </p> <p>Ce contexte influence fortement le choix des outils, chacun ayant ses propres limitations.</p> <p>De la m\u00eame mani\u00e8re, une bonne connaissance du jeu est indispensable pour proposer des optimisations contextuelles : - La cam\u00e9ra se d\u00e9place-t-elle ? - Le jeu est-il dynamique ou plut\u00f4t statique ? - Le lighting est-il statique ou dynamique ? - \u00c0 quelle distance observe-t-on la sc\u00e8ne ? - Etc.  </p> <p>Ce tutoriel est con\u00e7u sous la forme d\u2019un TP bas\u00e9 sur des cas pratiques afin de vous permettre de manipuler les outils et de comprendre par vous-m\u00eame.</p> <p>Toutes les ressources sont disponibles ici : Google drive</p>"},{"location":"tutorials/GPUProfiling/00_Introduction/#resources","title":"Resources","text":"<ul> <li>Game Optimization Series by Ben Cloward : https://www.youtube.com/watch?v=jt8b0cpjUVk&amp;list=PL78XDi0TS4lG4wvgfyGECmB8XiJLCgfFD</li> </ul>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/","title":"RenderDoc \u2013 Frame Analysis (1h)","text":""},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#introduction","title":"Introduction","text":"<p>Dans ce TP, nous allons ouvrir et analyser une capture de jeu \u00e0 l'aide de RenderDoc. La capture a \u00e9t\u00e9 r\u00e9alis\u00e9e dans le template URP 3D Sample du moteur Unity.</p> <p>Ce template utilise l\u2019Universal Render Pipeline, qui contient un grand nombre de features de rendu. L\u2019objectif n\u2019est pas d\u2019analyser chaque \u00e9l\u00e9ment en d\u00e9tail, mais d\u2019apprendre \u00e0 utiliser RenderDoc pour naviguer dans la composition d\u2019une frame et inspecter les diff\u00e9rentes ressources : textures, buffers, shaders, etc.</p> TP <p>R\u00e9pondez simplement aux questions encadr\u00e9es, creusez et posez des questions pour en apprendre plus.</p> <p>Info</p> <p>Si vous \u00eates bloqu\u00e9, n\u2019h\u00e9sitez pas \u00e0 solliciter votre encadrant.</p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#premiers-pas","title":"Premiers pas","text":"<p>Unity et Unreal disposent d\u2019outils permettant de lancer une capture RenderDoc depuis l\u2019\u00e9diteur ou via script. Pour simplifier le processus, nous allons directement \u00e9tudier une capture effectu\u00e9e depuis l\u2019\u00e9diteur Unity.</p> <p>T\u00e9l\u00e9charger renderdoc T\u00e9l\u00e9charger la capture (157 Mo)</p> <p>Vous pouvez ouvrir la capture via le menu <code>File &gt; Open Capture</code>.</p> <p>Voici le logiciel une fois la capture ouverte :</p> <p></p> <ul> <li>Event Browser Permet de naviguer \u00e0 travers les diff\u00e9rentes phases et appels d\u2019API de la frame captur\u00e9e. Chaque \u00e9v\u00e9nement poss\u00e8de un ID et certains sont regroup\u00e9s par sections.</li> <li>Texture Viewer Permet de visualiser les textures utilis\u00e9es lors d\u2019un \u00e9v\u00e9nement.</li> <li>Pipeline State Permet de visualiser les \u00e9tats du pipeline lors d\u2019un drawcall : ressources attach\u00e9es, shader utilis\u00e9, etc.</li> <li>Mesh Viewer Permet d\u2019inspecter les donn\u00e9es du mesh utilis\u00e9 lors d\u2019un drawcall.</li> <li>Resource Inspector Regroupe toutes les ressources cr\u00e9\u00e9es durant la frame.</li> </ul> <p>Pour faciliter la navigation, v\u00e9rifiez que le filtre de l\u2019Event Browser soit <code>$action()</code>.</p> <p>Avec le Texture Viewer ouvert, ouvrez la section <code>(EID 511-6810) FrameTime.GPU &gt; UIR.DrawChain</code> et parcourez les diff\u00e9rents \u00e9l\u00e9ments.</p> <p>Questions</p> <p>\u00c0 quoi correspondent, selon vous, les sections <code>GUITexture.Draw</code> ? Quelle section est la plus susceptible de nous int\u00e9resser ?</p> <p>Les captures peuvent contenir une grande quantit\u00e9 d\u2019\u00e9v\u00e9nements et de donn\u00e9es non pertinentes. Il est donc essentiel de savoir naviguer efficacement.</p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#composition-de-la-frame","title":"Composition de la Frame","text":"<p>Positionnez-vous sur la section <code>(EID 1427-6715) ScriptableRenderer.Execute: PC_High_Renderer</code>. En gardant le Texture Viewer ouvert, parcourez les diff\u00e9rentes sections.</p> <p>Question</p> <p>D\u00e9crivez bri\u00e8vement les diff\u00e9rentes passes de rendu du renderer. Pour chaque passe, donnez le nom des Outputs et votre intuition quant \u00e0 leur r\u00f4le. Certains outputs peuvent \u00eatre difficiles \u00e0 interpr\u00e9ter, c\u2019est normal. Ignorez l\u2019\u00e9v\u00e9nement LightCookies.</p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#draw-object-passes","title":"Draw Object Passes","text":"<p>On observe deux passes principales pour dessiner les objets : une pour les objets opaques et une pour les objets transparents.</p> <p>Une particularit\u00e9 du renderer Unity est qu\u2019il ne clear jamais la target de couleur. Il devient donc difficile de visualiser les drawcalls. Pour cela, utilisez l\u2019overlay <code>Clear Before Pass</code>, qui force le clear de la target avant la passe.</p> <p></p> <p>En naviguant dans les drawcalls de <code>RenderLoop.DrawSRPBatcher</code>, vous pouvez voir les objets se dessiner progressivement. Vous pouvez \u00e9galement utiliser l\u2019overlay <code>Highlight Drawcall</code> pour mettre en \u00e9vidence l\u2019objet rendu.</p> <p>Question</p> <p>S\u00e9lectionnez l\u2019output de Depth. Utilisez la baguette pour ajuster automatiquement la depth range.</p> <p> </p> <p>Que pouvez-vous observer entre les diff\u00e9rents drawcalls ?</p> <p>Pour valider votre intuition, choisissez un drawcall et ouvrez la fen\u00eatre Pipeline State.</p> <p></p> <p>En haut, vous retrouvez les diff\u00e9rents stages du pipeline graphique.</p> <p>Cliquez sur le stage <code>Framebuffer Output (FB)</code>. Le Depth State appara\u00eet en bas.</p> <p>Question</p> <p>D\u00e9crivez le depth state et validez (ou non) votre intuition. En revenant sur les passes observ\u00e9es, quel lien pouvez-vous \u00e9tablir ?</p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#etude-dun-drawcall","title":"\u00c9tude d\u2019un DrawCall","text":"<p>Choisissez un autre drawcall de la passe <code>DrawOpaqueObjects</code> et ouvrez la fen\u00eatre <code>Pipeline State</code>. S\u00e9lectionnez un drawcall visuellement identifiable.</p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#vertex-input","title":"Vertex Input","text":"<p>Question</p> <p>Quels sont les attributs d\u00e9finis par Unity ? Unity utilise-t-il un seul ou plusieurs buffers pour les vertices ? \u00c9crivez en C++ la structure correspondant au mod\u00e8le de l\u2019objet.</p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#vertex-shader","title":"Vertex Shader","text":"<p>Explorez les informations disponibles. Vous pouvez inspecter les uniforms en cliquant sur la fl\u00e8che dans la section Go.</p> <p>Question</p> <p>O\u00f9 se trouvent les matrices ViewProjection (VP) et ObjectToWorld (M) ? Que d\u00e9duisez-vous du nom des Uniform Buffers ?</p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#fragment-shader","title":"Fragment Shader","text":"<p>On constate que de nombreuses ressources sont utilis\u00e9es par le fragment shader, notamment les ShadowMaps g\u00e9n\u00e9r\u00e9es dans les passes pr\u00e9c\u00e9dentes.</p> <p>Exercice</p> <p>Ouvrez le shader en mode \u00e9dition :</p> <p></p> <p>Le shader est obfusqu\u00e9 mais \u00e9crit en GLSL. Modifiez-le pour que l\u2019objet dessin\u00e9 soit vert (0, 1, 0).</p> <p></p> Exercice (Bonus 1) <p>Explorons une frame du jeu Qwent. Essayez de comprendre comment fonctionne leur carte anim\u00e9e. Identifiez \u00e9galement une erreur potentiellement dangereuse commise par les d\u00e9veloppeurs dans cette frame (tutorial). T\u00e9l\u00e9charger la capture (147.2 Mo)</p> Exercice (Bonus 2) <p>Comme dans l\u2019exercice pr\u00e9c\u00e9dent, modifiez le shader pour qu\u2019il affiche les UVs de l\u2019objet. Vous devrez examiner le code du vertex shader.</p> <p></p>"},{"location":"tutorials/GPUProfiling/01_FrameAnalysis/#pour-aller-plus-loin","title":"Pour aller plus loin","text":"<p>Nous avons couvert les fonctionnalit\u00e9s de base. Pour aller plus loin, consultez la documentation officielle.</p>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/","title":"Profiling GPU \u2013 PIX (1h)","text":""},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#introduction","title":"Introduction","text":"<p>Le profiling GPU permet d'identifier et de comprendre les goulots d\u2019\u00e9tranglement. Plusieurs types de bottlenecks peuvent \u00eatre identifi\u00e9s dans un shader : la bande passante m\u00e9moire, l\u2019utilisation des ALU (arithmetic logic units), le sampling, ou l'interpolationn des varying... Il est donc essentiel de comprendre les limitations techniques du GPU que l\u2019on utilise.</p>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#les-outils","title":"Les outils","text":"<p>Il existe de nombreux outils de profiling GPU selon les fabricants d\u2019API ou d\u2019hardware :</p> Plateforme / Syst\u00e8me Outil de Profilage / Debug GPU Remarques DirectX (PC Windows) PIX Metal (macOS / iOS) Instruments / Xcode GPU Frame Capture AMD AMD Radeon\u2122 GPU Profiler NVIDIA (PC, Laptop, Workstation) Nsight Nintendo Switch NX Graphics Debugger Disponible uniquement pour d\u00e9veloppeurs agr\u00e9\u00e9s Android (OpenGL / Vulkan / GPU) Adreno Profiler, ARM Mali GPU Profiler Selon le GPU du device PlayStation 5 PS5 GPU Profiler Disponible uniquement pour d\u00e9veloppeurs enregistr\u00e9s Xbox Series X/S Xbox Developer Kit GPU Profiler Disponible uniquement pour d\u00e9veloppeurs enregistr\u00e9s"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#quelques-exemples","title":"Quelques exemples","text":"<p>Xcode poss\u00e8de d\u2019excellents outils de profiling CPU / m\u00e9moire / GPU, ainsi que du shader profiling : Documentation Xcode Shader Tools</p> <p>Overview </p> <p>GPU profiling </p> <p>Shader profiling </p> <p>Mali Offline Compiler : Vid\u00e9o explicative</p> <p></p>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#tp","title":"TP","text":"<p>Pour ce TP, nous allons utiliser PIX, version 2509 T\u00e9l\u00e9charger Pix </p> <p>Nous allons analyser une frame de mon PFE sous DirectX 12 sur PC. Gardez en t\u00eate que ce projet est con\u00e7u pour tourner sur Nintendo Switch : le test sera donc biais\u00e9 par le mat\u00e9riel utilis\u00e9, mais ce biais reste acceptable pour comprendre le profiling GPU.</p> <p>T\u00e9l\u00e9charger le jeu (304.7 Mo) T\u00e9l\u00e9charger la capture (534.6 Mo) </p> <p>Ajoutez l\u2019onglet Pipeline \u00e0 c\u00f4t\u00e9 de l\u2019onglet Warning et s\u00e9lectionnez-le. S\u00e9lectionnez RTV 0 et explorez le champ Visualization.</p> <p>D\u00e9ployez ensuite la fen\u00eatre Execution Duration dans la timeline.</p>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#comprendre-le-contexte-du-jeu","title":"Comprendre le contexte du jeu","text":"<p>Question</p> <p>D\u00e9crivez rapidement les grandes \u00e9tapes de rendu du jeu. Le jeu tourne normalement \u00e0 60 FPS sur Switch. Pourquoi tourne-t-il l\u00e9g\u00e8rement au-dessus de 60 FPS sur PC ?</p>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#comprendre-le-systeme-de-terrain","title":"Comprendre le syst\u00e8me de terrain","text":"<p>Nous allons commencer par \u00e9tudier le terrain.</p> <p>Question</p> <p>Estimez rapidement le temps n\u00e9cessaire pour calculer le terrain. Comprenez-vous comment il est rendu ? Connaissez-vous le nom de cette technique ? Quels en sont les avantages ? Quels sont ses plus gros d\u00e9savantages ? Quelles optimisations proposeriez-vous ?</p> <p> </p>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#les-robots","title":"Les robots","text":"<p>Question</p> <p>Combien de temps faut-il pour rendre les robots ? Comment sont-ils rendus, et avec quelle technique ? Cette technique a-t-elle un impact sur le GPU selon vous ?</p> <p>Dans la fen\u00eatre Tools &gt; Dr PIX, s\u00e9lectionnez Primitive &amp; Rasterization. Choisissez l\u2019event du draw des robots, lancez un test et notez la valeur de Quad Efficiency. Faites le m\u00eame test avec un terrain.</p> <p>Question</p> <p>Que remarquez-vous ? Pourquoi cette valeur n\u2019est-elle pas de 100% pour le terrain ?</p> <p>Je vous recommande cette vid\u00e9o pour comprendre l\u2019importance de ce ph\u00e9nom\u00e8ne : When Optimisations Work, But for the Wrong Reasons \u2013 SimonDev</p>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#comprendre-les-unites-du-gpu","title":"Comprendre les unit\u00e9s du GPU","text":"<p>Pour analyser un shader en profondeur, il est important de conna\u00eetre les unit\u00e9s impliqu\u00e9es :</p> <ul> <li>Varying (Interpolation) </li> <li>ALU   (plusieurs types selon le GPU ; certaines unit\u00e9s sont sp\u00e9cialis\u00e9es en FP16 ou FP32, d\u2019autres dans les FMA, etc.)</li> <li>Texture load / read / sampler</li> <li>Autres unit\u00e9s sp\u00e9cialis\u00e9es\u2026</li> </ul>"},{"location":"tutorials/GPUProfiling/02_GPUProfiling/#ressources","title":"Ressources","text":"<p>Pistes de profiling simples :</p> <ul> <li>Texture atlas  </li> <li>VAT  </li> <li>Instancing  </li> <li>Merger les props  </li> <li>Traquer les micro-triangles  </li> </ul> <p>Liens utiles :</p> <ul> <li> <p>D\u00e9monstration sur les <code>if</code> dans les shaders : ShaderToy \u2013 Branching </p> </li> <li> <p>Vid\u00e9o GDC d\u00e9mystifiant les croyances sur les shaders : Investigating and Dispelling Shader Myths </p> </li> <li> <p>Documentation sur le tile-based rendering mobile : Samsung \u2013 GPU framebuffer </p> </li> </ul>"},{"location":"tutorials/GPUProfiling/03_RapportProfiling/","title":"Rapport de profiling GPU \u2013 Pix (1 h)","text":"<p>Avant de passer \u00e0 la suite, posez-vous la question suivante : Que devrait contenir un rapport de profiling selon vous ?</p> <p>Un rapport de profiling est un document permettant de mieux comprendre le fonctionnement d\u2019un jeu. Il peut contenir diff\u00e9rents \u00e9l\u00e9ments d\u2019analyse :</p> <ul> <li>Profiling CPU  </li> <li>Profiling GPU  </li> <li>Analyse des draw calls et du bus CPU/GGPU  </li> <li>Impact RAM  </li> <li>Impact VRAM ou RAM/VRAM (tr\u00e8s important sur iOS -&gt; m\u00e9moir unifi\u00e9)  </li> <li>Analyse des spikes et freezes  </li> <li>Consommation d\u2019\u00e9nergie et \u00e9volution de la batterie (important sur mobile)  </li> <li>Chauffe du device (important sur mobile)  </li> </ul>"},{"location":"tutorials/GPUProfiling/03_RapportProfiling/#definir-le-cadre-du-rapport","title":"D\u00e9finir le cadre du rapport","text":"<p>Avant de produire un rapport de profiling, il est essentiel de d\u00e9finir :</p> <ul> <li>Le device utilis\u00e9 pour le test (low-end ou device \u00e9quip\u00e9 des meilleurs outils)  </li> <li>Les sc\u00e8nes \u00e0 analyser (home screen, core gameplay, cas sp\u00e9cifiques)  </li> <li>Les conditions du test (premier lancement, device chaud, build release ou dev)  </li> <li>Les param\u00e8tres graphiques utilis\u00e9s (settings low / medium / high)  </li> </ul> <p>Il est important d\u2019expliquer clairement le contexte et d\u2019ajouter des screenshots, car le jeu \u00e9volue rapidement. Cela permet de comparer les donn\u00e9es \u00e0 long terme et de conserver un rapport exploitable.</p>"},{"location":"tutorials/GPUProfiling/03_RapportProfiling/#exemple-de-rapport-de-profiling","title":"Exemple de rapport de profiling","text":"<p>Ce rapport est simple, mais il m\u2019a permis d\u2019\u00e9tudier les presets graphiques du jeu sur lequel je travaillais et de mieux les ajuster.</p> <p>Question</p> <p>R\u00e9alisez maintenant votre propre analyse sur un projet de votre choix (celui fourni ou un autre en dev build si possible).  Essayez de comprendre le fonctionnement du jeu et analysez l\u2019une de ses frames. T\u00e9l\u00e9charger la capture renderdoc de LoggedOut! (472.9 Mo) T\u00e9l\u00e9charger la capture pix de LoggedOut! (534.6 Mo) T\u00e9l\u00e9charger la capture renderdoc de Qwent (147.2 Mo) T\u00e9l\u00e9charger la capture renderdoc de prince of persia (1.55 Go) </p> <p>Comprendre le fonctinnement d'une frame est une pratique courante chez les d\u00e9veloppeurs rendu. Elle permet de rester \u00e0 jour et de comprendre diff\u00e9rentes techniques de rendering.</p> <p>Consultez par exemple : Graphics Studies Compilation</p>"},{"location":"tutorials/LearnOpenGL/","title":"LearnOpenGL Tutorials","text":""},{"location":"tutorials/LearnOpenGL/#scene-graph","title":"Scene Graph","text":"<p>Scene Graph \u2014 LearnOpenGL</p> Pr\u00e9visualisation <p></p>"},{"location":"tutorials/LearnOpenGL/#frustum-culling","title":"Frustum Culling","text":"<p>Frustum Culling \u2014 LearnOpenGL</p> Pr\u00e9visualisation <p></p>"}]}